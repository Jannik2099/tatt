#!/usr/bin/env python

# Global Modules
from subprocess import *
import sys
import re
import os

from tatt.gentooPackage import gentooPackage as gP
import tatt.packageFinder as packageFinder
from tatt.scriptwriter import writeusecombiscript as writeUSE
from tatt.scriptwriter import writerdepscript as writeRdeps
from tatt.scriptwriter import writesucessreportscript as writeSuccess
from tatt.scriptwriter import writecommitscript as writeCommit
from tatt.scriptwriter import writeCleanUpScript as writeCleanup
from tatt.bugbrowser import launch_browser as launch_browser
from tatt.tattConfig import tattConfig as tattConfig

##### Generate a global config obj, reading from ~/.tatt #####
config = tattConfig()

######### Main program starts here ###############

### USAGE and OPTIONS ###
from optparse import OptionParser

parser=OptionParser()
parser.add_option("-d", "--depend",
                  help="Determine stable rdeps",
                  dest="depend",
                  action="store_true",
                  default = False)
parser.add_option("-u", "--use", "--usecombis",
                  help="Determine use flag combinations",
                  dest="usecombi",
                  action="store_true",
                  default = False)
parser.add_option("-f", "--file", 
                  help="Input File containing packages",
                  dest="infile",
                  action="store"
                  )
parser.add_option("-j", "--jobname",
                  help="name for the job, prefix of output files",
                  dest="jobname",
                  action="store")
parser.add_option("-b", "--bug",
                  help="do the full program for a given stable request bug",
                  dest="bugnum",
                  action="store")
parser.add_option("-s", "--success",
		  help="Comment that the program was successfully tested",
                  dest="succbugnum",
		  action="store")
parser.add_option("-r", "--resolve",
		  help="Resolve the given bugnumber, needs a message",
                  dest="resolvenum",
		  action="store")
parser.add_option("-c", "--close",
		  help="Resolve the given bugnumber with closing it, needs to be combined with -r",
                  dest="close",
		  action="store_true")
parser.add_option("-m", "--message",
		  help="Message for bug resolution.",
                  dest="resolvemessage",
		  action="store")
parser.add_option("-v", "--verbose",
		  help="Print informative output.",
                  dest="verbose",
		  action="store_true",
                  default = False)
parser.add_option("-o", "--overview" "--browse",
		  help="Launch the bug browser",
                  dest="bugbrowser",
		  action="store_true",
                  default = False)

(options,args) = parser.parse_args()

# We copy some options to the config
config['verbose']=options.verbose

## Checking for root, tatt should be run as a user, I guess.
## Remove on occasion.
if (Popen(['whoami'], stdout=PIPE).communicate()[0].rstrip() == 'root'):
    isroot=True
else:
    print("You're not root!")
    isroot=False

## -s and a bugnumber was given ?
if options.succbugnum:
    print("Reporting success for bug number " + options.succbugnum)
    retcode = call(['bugz', 'modify', options.succbugnum, '-c', config['successmessage']])
    if retcode == 0:
        print("Success!");
        exit (0)
    else:
        print("Failure commenting on Bugzilla")
        exit(1)

if options.bugbrowser:
    # Launch the bugbrowser
    launch_browser (config)
    exit (0)
    
# Will eventuall contain packages to handle:
packs=None

## If -f and a filename have been given:
if options.infile: 
    try:
        packfile=open(options.infile, 'r')
    except IOError:
        print("Given filename not found !")
        exit(1)
    packraw = packfile.read()
    packfile.close()
    packs = packageFinder.findPackages(packraw, re.compile(config['atom-regexp']))

## -b and a bugnumber was given ?
if options.bugnum:
    print("Bugnumber:  " + options.bugnum)
    # If packs is still empty we search in the bug-title
    if packs==None:
        p1 = Popen(['bugz', 'get', options.bugnum, '-n'], stdout=PIPE)
        bugraw = Popen(['grep', 'Title'], stdin=p1.stdout, stdout=PIPE).communicate()[0]
        if not re.search('[Ss][Tt][Aa][Bb]', bugraw):
            print("Does not look like a stable request bug !")
            print(bugraw)
        packs = packageFinder.findPackages(bugraw, re.compile(config['atom-regexp']))

# joint code for -f and -b
##########################

if not packs==None:
    ## Assigning jobname
    if options.jobname:
        jobname = options.jobname
    elif options.infile:
        jobname = options.infile
    else:
        jobname = packs[0].packageName()
    print ("Jobname: " + jobname)
    
    for p in packs:
        print("Found the following package atom : " + p.packageString())

    # Unmasking:
    if isroot:
        # If we are root, then we can write to package.keywords
        try:
            unmaskfile=open(config['unmaskfile'], 'r+')
        except IOError:
            # create an empty file, this should be beautified
            unmaskfile=open(config['unmaskfile'], 'w')
            unmaskfile.write(" ")
            unmaskfile.close()
            unmaskfile=open(config['unmaskfile'], 'r+')

        unmaskfileContent = unmaskfile.read()
        for p in packs:
            # Test if unmaskfile already contains the atom
            if re.search(p.packageString(), unmaskfileContent):
                print (p.packageString() + " already in package.keywords.")
            else:
                unmaskfile.write("\n" + p.packageString() + "\n")
                print ("Appended " + p.packageString()+ " to /etc/portage/package.keywords/arch")
        unmaskfile.close()
    else:
        print ("You are not root, your unmaskstring would be:")
        print ("\n".join([p.packageString() for p in packs]) + "\n")
    ## Write the scripts
    writeUSE(jobname, packs, config)
    writeRdeps(jobname, packs, config)
    writeCleanup (jobname, config)
    ## Config and Successscript can only be written if we have a bugnumber
    if options.bugnum:
        writeSuccess(jobname, options.bugnum, config)
        writeCommit(jobname, options.bugnum, packs, config)
    exit (0)

# Code for resolving bugs (-r and -m)
#####################################
if options.resolvenum:
    if not options.resolvemessage:
        print("Please call with a message per -m")
        exit (1)
    print("Resolving bug number " + options.resolvenum)
    calllist = ['bugz', 'modify', options.resolvenum, '-c', options.resolvemessage, '--remove-cc', config['arch']+"@gentoo.org"]
    if options.close:
        calllist = calllist + ['--fixed']
    retcode = call(calllist)
    if retcode == 0:
        print("Success!");
        exit (0)
    else:
        print("Failure accessing bugzilla.")
        exit(1)


## If we arrive here then a package atom should be given
try:
    pack = gP(args[0])
except IndexError:
    print("Please call with package atom as argument")
    exit (1)

if options.depend:
    writeRdeps(pack.packageName(), [pack])

if options.usecombi:
    writeUSE(pack.packageName(), [pack], config["ignoreprefix"])

## That's all folks ##
